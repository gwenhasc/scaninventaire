# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nk8t7FGLPFEEv3GPNERgoquY48WmDTEA
"""

import streamlit as st
import pandas as pd
from io import StringIO
from datetime import datetime

st.set_page_config(page_title="Inventaire scan EAN", layout="wide")

st.title("üì¶ Inventaire ‚Äî Scan EAN ‚Üí Compteur ‚Üí Export CSV")

st.markdown(
    """
**Principe :** tu scannes un code (EAN1 ou EAN2).
- Si tu scannes **EAN1** ‚Üí √ßa incr√©mente le produit.
- Si tu scannes **EAN2** ‚Üí √ßa incr√©mente **le produit de son EAN1 (alias)**.
"""
)

REQUIRED_COLS = ["EAN 1", "EAN 2", "Reference", "Name", "Couleur", "Taille", "Pointure"]

def normalize_code(x: str) -> str:
    if x is None:
        return ""
    x = str(x).strip()
    # certains scanners ajoutent des espaces / retours ; on nettoie
    x = x.replace("\n", "").replace("\r", "").replace(" ", "")
    return x

def load_products(csv_bytes) -> pd.DataFrame:
    df = pd.read_csv(csv_bytes, dtype=str, keep_default_na=False)
    df.columns = [c.strip() for c in df.columns]

    missing = [c for c in REQUIRED_COLS if c not in df.columns]
    if missing:
        raise ValueError(f"Colonnes manquantes dans produits.csv : {missing}")

    for col in ["EAN 1", "EAN 2"]:
        df[col] = df[col].apply(normalize_code)

    # s√©curit√©s
    if df["EAN 1"].eq("").any():
        raise ValueError("Certains produits ont un EAN 1 vide. EAN 1 est obligatoire.")

    # doublons EAN1
    if df["EAN 1"].duplicated().any():
        dups = df[df["EAN 1"].duplicated(keep=False)]["EAN 1"].unique().tolist()
        raise ValueError(f"Doublons d√©tect√©s dans EAN 1 : {dups[:10]}{'...' if len(dups)>10 else ''}")

    return df

def build_alias_map(df: pd.DataFrame) -> dict:
    """
    map_code_to_ean1 : code scann√© (EAN1 ou EAN2) -> EAN1
    """
    m = {}
    for _, row in df.iterrows():
        ean1 = row["EAN 1"]
        ean2 = row["EAN 2"]

        if ean1:
            m[ean1] = ean1

        if ean2:
            # si EAN2 d√©j√† utilis√© par un autre produit, on avertira
            if ean2 in m and m[ean2] != ean1:
                # conflit
                raise ValueError(f"Conflit : EAN 2 '{ean2}' pointe vers plusieurs EAN 1 ({m[ean2]} et {ean1}).")
            m[ean2] = ean1

    return m

def init_session_state():
    if "products" not in st.session_state:
        st.session_state.products = None
    if "alias_map" not in st.session_state:
        st.session_state.alias_map = {}
    if "counts" not in st.session_state:
        st.session_state.counts = {}  # ean1 -> qty
    if "scan_log" not in st.session_state:
        st.session_state.scan_log = []  # dict rows
    if "unknown" not in st.session_state:
        st.session_state.unknown = {}  # code -> qty

init_session_state()

with st.sidebar:
    st.header("‚öôÔ∏è Configuration")
    prod_file = st.file_uploader("Importer `produits.csv`", type=["csv"])

    colA, colB = st.columns(2)
    with colA:
        if st.button("üßπ R√©initialiser inventaire", use_container_width=True):
            st.session_state.counts = {}
            st.session_state.scan_log = []
            st.session_state.unknown = {}
            st.success("Inventaire r√©initialis√©.")
    with colB:
        if st.button("üß™ Charger un exemple", use_container_width=True):
            sample = StringIO(
                "EAN 1,EAN 2,Reference,Name,Couleur,Taille,Pointure\n"
                "3700000000001,3700000000002,REF-001,Chaussettes Alpaga,Noir,M,39-42\n"
                "3700000000003,,REF-002,Bonnet Alpaga,Beige,Unique,\n"
            )
            df = load_products(sample)
            st.session_state.products = df
            st.session_state.alias_map = build_alias_map(df)
            st.success("Exemple charg√©.")

if prod_file is not None:
    try:
        df = load_products(prod_file)
        st.session_state.products = df
        st.session_state.alias_map = build_alias_map(df)
        st.success(f"Produits charg√©s : {len(df)} lignes")
    except Exception as e:
        st.session_state.products = None
        st.session_state.alias_map = {}
        st.error(str(e))

if st.session_state.products is None:
    st.warning("Importe ton `produits.csv` (ou clique *Charger un exemple*).")
    st.stop()

products = st.session_state.products
alias_map = st.session_state.alias_map

# --- Scan UI
st.subheader("üîé Scan")
st.caption("Astuce : ton scanner USB envoie le code comme du texte + ENTER. Clique dans le champ puis scanne en boucle.")

scan_col1, scan_col2 = st.columns([2, 1])

with scan_col1:
    code = st.text_input("Code scann√© (EAN1 ou EAN2)", value="", placeholder="Scanne ici‚Ä¶", key="scan_input")

with scan_col2:
    qty = st.number_input("Quantit√© √† ajouter", min_value=1, value=1, step=1)

def register_scan(raw_code: str, add_qty: int):
    raw_code = normalize_code(raw_code)
    if not raw_code:
        return

    ts = datetime.now().isoformat(timespec="seconds")

    if raw_code in alias_map:
        ean1 = alias_map[raw_code]
        st.session_state.counts[ean1] = st.session_state.counts.get(ean1, 0) + int(add_qty)
        st.session_state.scan_log.append({
            "timestamp": ts,
            "code_scann√©": raw_code,
            "ean1_resolu": ean1,
            "quantit√©": int(add_qty),
            "statut": "OK"
        })
        # feedback
        prod = products.loc[products["EAN 1"] == ean1].iloc[0]
        st.toast(f"‚úÖ {prod['Name']} ({prod['Reference']}) +{add_qty}", icon="‚úÖ")
    else:
        st.session_state.unknown[raw_code] = st.session_state.unknown.get(raw_code, 0) + int(add_qty)
        st.session_state.scan_log.append({
            "timestamp": ts,
            "code_scann√©": raw_code,
            "ean1_resolu": "",
            "quantit√©": int(add_qty),
            "statut": "INCONNU"
        })
        st.toast(f"‚ö†Ô∏è Code inconnu : {raw_code} (+{add_qty})", icon="‚ö†Ô∏è")

if st.button("Ajouter le scan", type="primary"):
    register_scan(code, qty)
    st.session_state.scan_input = ""  # reset field

# --- R√©sultats
st.divider()
st.subheader("üìä R√©sultats inventaire")

# build output table
out = products.copy()
out["Quantite"] = out["EAN 1"].map(st.session_state.counts).fillna(0).astype(int)

tab1, tab2, tab3 = st.tabs(["Produits compt√©s", "Codes inconnus", "Journal des scans"])

with tab1:
    st.dataframe(
        out.sort_values(["Quantite", "Reference"], ascending=[False, True]),
        use_container_width=True,
        hide_index=True
    )

    csv_bytes = out.to_csv(index=False).encode("utf-8-sig")
    st.download_button(
        "‚¨áÔ∏è T√©l√©charger CSV inventaire",
        data=csv_bytes,
        file_name="inventaire_export.csv",
        mime="text/csv",
        use_container_width=True
    )

with tab2:
    if st.session_state.unknown:
        unk_df = pd.DataFrame(
            [{"code_scann√©": k, "quantite": v} for k, v in st.session_state.unknown.items()]
        ).sort_values("quantite", ascending=False)
        st.dataframe(unk_df, use_container_width=True, hide_index=True)

        st.download_button(
            "‚¨áÔ∏è T√©l√©charger CSV codes inconnus",
            data=unk_df.to_csv(index=False).encode("utf-8-sig"),
            file_name="codes_inconnus.csv",
            mime="text/csv",
            use_container_width=True
        )
    else:
        st.info("Aucun code inconnu üëç")

with tab3:
    log_df = pd.DataFrame(st.session_state.scan_log)
    if not log_df.empty:
        st.dataframe(log_df, use_container_width=True, hide_index=True)
        st.download_button(
            "‚¨áÔ∏è T√©l√©charger journal des scans",
            data=log_df.to_csv(index=False).encode("utf-8-sig"),
            file_name="scan_log.csv",
            mime="text/csv",
            use_container_width=True
        )
    else:
        st.info("Pas encore de scans.")